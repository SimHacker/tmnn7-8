From uucp Sun Apr 30 18:10 EDT 1989
>From ATHENA.MIT.EDU!tytso  Sun Apr 30 18:10:21 1989 remote from uunet
Received: by snark.UUCP (smail2.3)
	id AA13972; 30 Apr 89 18:10:21 EDT (Sun)
Received: from ATHENA.MIT.EDU by uunet.uu.net (5.61/1.14) with SMTP 
	id AA16577; Sun, 30 Apr 89 16:47:35 -0400
Received: by ATHENA.MIT.EDU (5.45/4.7) id AA11221; Sun, 30 Apr 89 16:46:40 EDT
Received: by BINKLEY.MIT.EDU (5.45/4.7) id AA02545; Sun, 30 Apr 89 16:44:55 EDT
Date: Sun, 30 Apr 89 16:44:55 EDT
From: Theodore Ts'o <uunet!ATHENA.MIT.EDU!tytso>
Message-Id: <8904302044.AA02545@BINKLEY.MIT.EDU>
To: eric%snark.uucp
Cc: ambar@ATHENA.MIT.EDU
Subject: patch to nntpxmit.c and report_perl 
Reply-To: uunet!athena.mit.edu!tytso
Address: EC Bemis 307, 3 Ames Street, Cambridge, MA 02139
Phone: (617) 225-6367
Status: R

Here you go....  this is the patches to nntpxmit to get it to work with
batch files.  It gets used just as nntp would be used in a news 2.11
system:  nntpsend gets kicked off by cron every so often, which runs
nntpxmit as it discovers queue files in /usr/spool/news/batch.  The
queue files must have the name of the internet host of that is
associated with the queue file.

Also included is report_perl, which does a nice job of distilling the
log file down to relavant statistics and important messages.

						- Ted


#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	nntpxmit.patch
#	report_perl
# This archive created: Sun Apr 30 16:00:45 1989
export PATH; PATH=/bin:/usr/bin:$PATH
echo shar: "extracting 'nntpxmit.patch'" '(13740 characters)'
if test -f 'nntpxmit.patch'
then
	echo shar: "will not over-write existing file 'nntpxmit.patch'"
else
sed 's/^x//' << \SHAR_EOF > 'nntpxmit.patch'
xHere are patches to nntpxmit.c to allow nntpxmit to work with
xTMN-news.  Everything that is TMNN specific is #ifdefed under TMNN.
xHowever, some code is missing to make this work under news 2.11.  I
xhope to fix this real soon now, but you should only be applying this
xpatch if you intend to be using TMNN.  
x
xBascically, what's done is that I've revamped the unspooling process
xso that the queue file can have either article-id's or filenames.
x(TMNN spools things using just article-id's; News 2.11 spools things
xusing filenames.)  What's missing for news 2.11 is a way to translate
xarticle-id's to filenames --- it's obvious where this code should be
xinstalled.  It should be easy to steal it from server/misc.c; I just
xdon't have time to deal with it right now.
x
xA few caveats: 
x
x1) You must apply it to stock, unmodified nntpxmit distributed with NNTP
xversion 1.5.  Given how extensive the modifications are, and how
xnon-optimal the patch hunks generated by diff are, I doubt you will
xhave much luck with earlier versions or with versions that have been
xhacked that much.
x
x2) You need to have symlinks from the TMN-source tree to the xmit
xdirectory for the following files:
x	libnews.a
x	libport.a
x	libpriv.a
x	confignews.h
x	configsys.h
x	news.h
x	portlib.h
x	priv.h
x	system.h
x
x3)  You need to add libnews.a libport.a libpriv.a to the "LIBS = "
xline in the Makefile.
x
x4)  Keep a copy of the original nntpxmit sources, either manually, or
xvia RCS or SCCS.  If I make changes, it will be very likely that I
xwill just send another context diff with respect to the original
xsources, instead of an incremental patch.  
x
x5)  Use Larry Wall's patch program.  I pity the fool who tries to apply
xthis patch by hand.  If you don't have it, it should be available from
xuunet or your closes comp.sources archive.
x
x6)  Send bug reports or suggestions for features to
xtytso@bloom-beacon.mit.edu, or bloom-beacon!tytso.   
x
x				Theodore Ts'o
x				MIT Student Information Processing Board
x				(617) 253-7788		
x				tytso@athena.mit.edu
x				bloom-beacon!mit-athena!tytso
x	
x
xRCS file: RCS/nntpxmit.c,v
xretrieving revision 1.1
xdiff -c -r1.1 nntpxmit.c
x*** /tmp/,RCSt1025898	Sun Apr 30 00:08:58 1989
x--- nntpxmit.c	Sun Apr 30 00:06:52 1989
x***************
x*** 59,65 ****
x--- 59,75 ----
x  ** Erik E. Fair <fair@ucbarpa.berkeley.edu>, Dec 4, 1987
x  */
x  
x+ #define TMNN
x+ 
x+ #ifdef TMNN
x+ #include "news.h"
x+ #include "priv.h"
x+ void	hstread();
x+ char	*hstfile();
x+ #endif
x+ 
x  #include "nntpxmit.h"
x+ 
x  #include <stdio.h>
x  #include <errno.h>
x  #include <ctype.h>
x***************
x*** 88,94 ****
x  #define	MAXFNAME	BUFSIZ	/* maximum filename size - big enough? */
x  #define	FCLOSE(fp)	(void) fclose(fp); (fp) = (FILE *)NULL
x  
x! FILE	*getfp();
x  char	*errmsg();
x  void	requeue();
x  void	catchsig();
x--- 98,107 ----
x  #define	MAXFNAME	BUFSIZ	/* maximum filename size - big enough? */
x  #define	FCLOSE(fp)	(void) fclose(fp); (fp) = (FILE *)NULL
x  
x! FILE	*open_article();
x! char	*getnextart();
x! char	*msg2filename();
x! char	*msg2msgid();
x  char	*errmsg();
x  void	requeue();
x  void	catchsig();
x***************
x*** 108,113 ****
x--- 121,129 ----
x  ** stuff we've already sent.
x  */
x  char	*Pname;			/* this program's invocation name */
x+ #ifdef TMNN
x+ char	*Progname;
x+ #endif
x  char	*Host;			/* current remote host */
x  char	*Qfile;			/* current queue file we're operating on */
x  FILE	*Qfp;			/* the (FILE *) for above */
x***************
x*** 179,184 ****
x--- 195,203 ----
x  #endif	BSD4_2
x  
x  	Pname = ((Pname = rindex(av[0],'/')) ? Pname + 1 : av[0]);
x+ #ifdef TMNN
x+ 	Progname = Pname;
x+ #endif
x  	
x  	if (ac < 2) {
x  		fprintf(stderr, Fmt, Pname, USAGE);
x***************
x*** 202,207 ****
x--- 221,237 ----
x  	}
x  #endif	USELOG
x  
x+ #ifdef TMNN
x+ 	newsinit();	/* set up defaults and initialize. */
x+ #ifdef DEBUG
x+ 	if (!debug)
x+ 		loginit();
x+ #endif /* DEBUG */
x+ 	(void) rdactive(NULLPRED); /* history code needs the active-group data */
x+ 	hstread(TRUE);
x+ #endif
x+ 	
x+ 
x  	for(i = 1; i < ac; i++) {
x  		if (av[i][0] == '-') {
x  			switch(av[i][1]) {
x***************
x*** 361,367 ****
x  char	*host, *file;
x  int	transport, isQfile;
x  {
x- 	register FILE	*fp;
x  #ifdef	FTRUNCATE
x  	char	*mode = "r+";		/* so we can use ftruncate() */
x  #else
x--- 391,396 ----
x***************
x*** 368,374 ****
x  	char	*mode = "r";
x  #endif	FTRUNCATE
x  
x! 	if ((Qfp = fopen(file, mode)) == (FILE *)NULL) {
x  		char	buf[BUFSIZ];
x  
x  		sprintf(buf, E_fopen, file, mode, errmsg(errno));
x--- 397,403 ----
x  	char	*mode = "r";
x  #endif	FTRUNCATE
x  
x! 	if (isQfile && (Qfp = fopen(file, mode)) == (FILE *)NULL) {
x  		char	buf[BUFSIZ];
x  
x  		sprintf(buf, E_fopen, file, mode, errmsg(errno));
x***************
x*** 391,397 ****
x  	** Open a connection to the remote server
x  	*/
x  	if (hello(host, transport) == FAIL) {
x! 		FCLOSE(Qfp);
x  		return(FALSE);
x  	}
x  
x--- 420,427 ----
x  	** Open a connection to the remote server
x  	*/
x  	if (hello(host, transport) == FAIL) {
x! 		if (isQfile)
x! 			FCLOSE(Qfp);
x  		return(FALSE);
x  	}
x  
x***************
x*** 407,415 ****
x  		*/
x  		catchsig(interrupted);
x  
x! 		while((fp = getfp(Qfp, Article, sizeof(Article))) != (FILE *)NULL) {
x! 			if (!sendarticle(host, fp)) {
x! 				(void) fclose(fp);
x  				requeue(Article);
x  				Article[0] = '\0';
x  				cleanup();
x--- 437,444 ----
x  		*/
x  		catchsig(interrupted);
x  
x! 		while (getnextart(Qfp, Article, sizeof(Article))) {
x! 			if (!sendarticle(host, Article)) {
x  				requeue(Article);
x  				Article[0] = '\0';
x  				cleanup();
x***************
x*** 417,423 ****
x  				restsig();
x  				return(TRUE);
x  			}
x- 			(void) fclose(fp);
x  		}
x  
x  		cleanup();
x--- 446,451 ----
x***************
x*** 432,438 ****
x  		*/
x  		register int	retcode;
x  
x! 		retcode = sendarticle(host, Qfp);
x  		FCLOSE(Qfp);
x  		goodbye(retcode ? WAIT : DONT_WAIT);
x  		return(retcode && Stats.accepted == 1 && Stats.failed == 0);
x--- 460,466 ----
x  		*/
x  		register int	retcode;
x  
x! 		retcode = sendarticle(host, file);
x  		FCLOSE(Qfp);
x  		goodbye(retcode ? WAIT : DONT_WAIT);
x  		return(retcode && Stats.accepted == 1 && Stats.failed == 0);
x***************
x*** 448,472 ****
x  **	Watch all network I/O for errors, return FALSE if
x  **		the connection fails and we have to cleanup.
x  */
x! sendarticle(host, fp)
x  char	*host;
x! FILE	*fp;
x  {
x  	register int	code;
x  	char	buf[BUFSIZ];
x  	char	*e_xfer = "%s xfer: %s";
x  
x! 	switch(code = ihave(fp)) {
x  	case CONT_XFER:
x  		/*
x  		** They want it. Give it to 'em.
x  		*/
x  		if (!sendfile(fp)) {
x  			sprintf(buf, e_xfer, host, errmsg(errno));
x  			log(L_NOTICE, buf);
x  			Stats.failed++;
x  			return(FALSE);
x  		}
x  		/*
x  		** Did the article transfer OK?
x  		** Stay tuned to this same socket to find out!
x--- 476,514 ----
x  **	Watch all network I/O for errors, return FALSE if
x  **		the connection fails and we have to cleanup.
x  */
x! sendarticle(host, msgname)
x  char	*host;
x! char	*msgname;
x  {
x  	register int	code;
x  	char	buf[BUFSIZ];
x  	char	*e_xfer = "%s xfer: %s";
x+ 	FILE	*fp = NULL;
x+ 	char	msgid[BUFSIZ];
x+ 	char	filename[BUFSIZ];
x  
x! 	if (!msg2msgid(msgname, msgid, &fp))
x! 		return(FALSE);
x! 
x! 	switch(code = ihave(msgid)) {
x  	case CONT_XFER:
x  		/*
x  		** They want it. Give it to 'em.
x  		*/
x+ 		if (!fp) {
x+ 			if (!msg2filename(msgname, filename))
x+ 				return(FALSE);
x+ 			if (!open_article(filename, &fp))
x+ 				return(FALSE);
x+ 		}
x  		if (!sendfile(fp)) {
x+ 			fclose(fp);
x  			sprintf(buf, e_xfer, host, errmsg(errno));
x  			log(L_NOTICE, buf);
x  			Stats.failed++;
x  			return(FALSE);
x  		}
x+ 		fclose(fp);
x  		/*
x  		** Did the article transfer OK?
x  		** Stay tuned to this same socket to find out!
x***************
x*** 512,517 ****
x--- 554,560 ----
x  	return(TRUE);
x  }
x  
x+ 
x  char *
x  errmsg(code)
x  int code;
x***************
x*** 558,564 ****
x  ** convert `s' to lower case
x  */
x  char *
x! lcase(s)
x  register char	*s;
x  {
x  	register char	*cp;
x--- 601,607 ----
x  ** convert `s' to lower case
x  */
x  char *
x! downcase(s)
x  register char	*s;
x  {
x  	register char	*cp;
x***************
x*** 592,598 ****
x  			if ((cp = index(buf, ':')) == (char *)NULL)
x  				continue;
x  			*cp++ = '\0';
x! 			if (strncmp(lcase(buf), msgid, sizeof(*msgid)) == 0) {
x  				/* dump extraneous trash - umass.bitnet */
x  				/* hope nobody quotes an '>' in a msgid */
x  				if ((cp2 = index(cp, '>')) != (char *)NULL)
x--- 635,642 ----
x  			if ((cp = index(buf, ':')) == (char *)NULL)
x  				continue;
x  			*cp++ = '\0';
x! 			if (strncmp(downcase(buf), msgid,
x! 				    sizeof(*msgid)) == 0) {
x  				/* dump extraneous trash - umass.bitnet */
x  				/* hope nobody quotes an '>' in a msgid */
x  				if ((cp2 = index(cp, '>')) != (char *)NULL)
x***************
x*** 748,771 ****
x  ** Read the header of a netnews article, snatch the message-id therefrom,
x  ** and ask the remote if they have that one already.
x  */
x! ihave(fp)
x! FILE	*fp;
x  {
x  	register int	code;
x- 	register char	*id;
x  	char	buf[BUFSIZ];
x  
x- 	if ((id = getmsgid(fp)) == (char *)NULL || *id == '\0') {
x- 		/*
x- 		** something botched locally with the article
x- 		** so we don't send it, but we don't break off
x- 		** communications with the remote either.
x- 		*/
x- 		sprintf(buf, "%s: message-id missing!", Article);
x- 		log(L_DEBUG, buf);
x- 		return(ERR_GOTIT);
x- 	}
x- 
x  	if (!msgid_ok(id)) {
x  		sprintf(buf, "%s: message-id syntax error: %s", Article, id);
x  		log(L_DEBUG, buf);
x--- 792,803 ----
x  ** Read the header of a netnews article, snatch the message-id therefrom,
x  ** and ask the remote if they have that one already.
x  */
x! ihave(id)
x! 	char	*id;
x  {
x  	register int	code;
x  	char	buf[BUFSIZ];
x  
x  	if (!msgid_ok(id)) {
x  		sprintf(buf, "%s: message-id syntax error: %s", Article, id);
x  		log(L_DEBUG, buf);
x***************
x*** 778,784 ****
x  	switch(code = converse(buf, sizeof(buf))) {
x  	case CONT_XFER:
x  		Stats.accepted++;
x- 		rewind(fp);
x  		return(code);
x  	case ERR_GOTIT:
x  		Stats.rejected++;
x--- 810,815 ----
x***************
x*** 789,841 ****
x  }
x  
x  /*
x! ** Given that fp points to an open file containing filenames,
x! ** open and return a file pointer to the next filename in the file.
x! ** Don't you love indirection?
x! **
x! ** Returns a valid FILE pointer or NULL if end of file.
x! */
x! FILE *
x! getfp(fp, filename, fnlen)
x! register FILE	*fp;
x! char	*filename;
x! register int	fnlen;
x  {
x! 	register FILE	*newfp = (FILE *)NULL;
x! 	register char	*cp;
x! 	char	*mode = "r";
x  
x! 	while(newfp == (FILE *)NULL) {
x! 		if (fgets(filename, fnlen, fp) == (char *)NULL)
x! 			return((FILE *)NULL);		/* EOF, tell caller */
x  
x- 		filename[fnlen - 1] = '\0';	/* make sure */
x- 
x  		/* if fgets() ever forgets the '\n', we're fucked */
x! 		if (*(cp = &filename[strlen(filename) - 1]) == '\n')
x  			*cp = '\0';
x  
x! 		if (filename[0] == '\0')
x! 			continue;
x  
x! 		if ((newfp = fopen(filename, mode)) == (FILE *)NULL) {
x! 			/*
x! 			** The only permissible error is `file non-existant'
x! 			** anything else indicates something is seriously
x! 			** wrong, and we should go away to let the shell
x! 			** script clean up.
x! 			*/
x! 			if (errno != ENOENT) {
x  				char	buf[BUFSIZ];
x  
x! 				sprintf(buf, E_fopen, filename, mode, errmsg(errno));
x  				log(L_WARNING, buf);
x  				goodbye(DONT_WAIT);
x  				exit(EX_OSERR);
x  			}
x  		}
x- 	}
x- 	return(newfp);
x  }
x  
x  /*
x--- 820,930 ----
x  }
x  
x  /*
x!  * Return the next article to be processed.  Depending on the type of
x!  * file, it may contain message-id's or actual filenames.
x!  */
x! char *getnextart(fp, msgname, len)
x! 	FILE	*fp;
x! 	char	*msgname;
x! 	int	len;
x  {
x! 	char	*cp;
x! 	
x! 	msgname[0] = '\0';
x! 	
x! 	while (msgname[0] == '\0') {
x! 		if (fgets(msgname, len, fp) == (char *)NULL)
x! 			return((char *)NULL);		/* EOF, tell caller */
x  
x! 		msgname[len - 1] = '\0';	/* make sure */
x  
x  		/* if fgets() ever forgets the '\n', we're fucked */
x! 		if (*(cp = &msgname[strlen(msgname) - 1]) == '\n')
x  			*cp = '\0';
x+ 	}
x+ 	return(msgname);
x+ }
x  
x! /*
x!  * Given a message name, convert it to a filename.
x!  */
x! char *msg2filename(msgname, filename)
x! 	char	*msgname, *filename;
x! {
x! 	char	*cp;
x  
x! 	if ((msgname[0] == '<') &&
x! 	    (msgname[strlen(msgname) -1] == '>')) {
x! #ifdef TMNN
x! 		cp = hstfile(msgname);
x! 		if (cp)
x! 			strcpy(filename, hstfile(msgname));
x! 		else {
x! 			filename[0]='\0';
x! 			return(NULL);
x! 		}
x! #else
x! 		**** You need to find a way to do the conversion for
x! 		**** non TMNN sites.  Stealing some code from
x! 		**** server/misc.c is the right thing to do.
x! #endif
x! 	} else
x! 		strcpy(filename, msgname);
x! 	return(msgname);
x! }
x! 
x! 
x! /*
x!  * Give a message name, convert it to a message-id.
x!  */
x! char *msg2msgid(msgname, msgid, fpp)
x! 	char	*msgname, *msgid;
x! 	FILE	**fpp;
x! {
x! 	char	*cp;
x! 	
x! 	if ((msgname[0] == '<') &&
x! 	    (msgname[strlen(msgname) -1] == '>'))
x! 		strcpy(msgid, msgname);
x! 	else {
x! 		msgid[0]='\0';
x! 		open_article(msgname, fpp);
x! 		if (!(cp = getmsgid(*fpp))) {
x! 			fclose(*fpp);
x! 			*fpp = NULL;
x! 			return(NULL);
x! 		}
x! 		rewind(*fpp);
x! 		strcpy(msgid, cp);
x! 	}
x! 	return(msgid);
x! }
x! 
x! FILE *open_article(filename, fpp)
x! 	char	*filename;
x! 	FILE	**fpp;
x! {
x! 	char	*mode = "r";
x! 	
x! 	if ((*fpp = fopen(filename, mode)) == (FILE *)NULL) {
x! 		/*
x! 		 ** The only permissible error is `file non-existant'
x! 		 ** anything else indicates something is seriously
x! 		 ** wrong, and we should go away to let the shell
x! 		 ** script clean up.
x! 		 */
x! 			if (errno == ENOENT) {
x! 				return(NULL);
x! 			} else {
x  				char	buf[BUFSIZ];
x  
x! 				sprintf(buf, E_fopen, filename, mode,
x! 					errmsg(errno));
x  				log(L_WARNING, buf);
x  				goodbye(DONT_WAIT);
x  				exit(EX_OSERR);
x  			}
x  		}
x  }
x  
x  /*
x***************
x*** 1143,1145 ****
x--- 1232,1241 ----
x  #endif	USG
x  	return(TRUE);
x  }
x+ 
x+ #ifdef TMNN
x+ xxit()
x+ {
x+ 	exit(0);
x+ }
x+ #endif
SHAR_EOF
if test 13740 -ne "`wc -c < 'nntpxmit.patch'`"
then
	echo shar: "error transmitting 'nntpxmit.patch'" '(should have been 13740 characters)'
fi
fi
echo shar: "extracting 'report_perl'" '(6862 characters)'
if test -f 'report_perl'
then
	echo shar: "will not over-write existing file 'report_perl'"
else
sed 's/^x//' << \SHAR_EOF > 'report_perl'
x#!/usr/bin/perl
xeval "exec /usr/bin/perl -S $0 $*"
x    if $running_under_some_shell;
x			# this emulates #! processing on NIH machines.
x			# (remove #! line above if indigestible)
x
x# 
x#  Perl script which eats TMN news log files and produces a summary of USENET
x#  traffic and errors over the period of time that the log was collected.
x#
x#  Note: In the linecount summary section, zero acrticles are not actually
x#	being detected.
x#
x#  Last revised:  April 30, 1989
x#
x#  Theodore Ts'o <tytso@athena.mit.edu>
x#  Originally written April 4, 1989
x#
x# This program was inspired by report_awk, an awk script that did the same
x# thing for News 2.10 and 2.11 log files.  Small bits of report_awk run 
x# through awk2perl have been lifted, especially the horribly messy printf 
x# specs in the summary section and some of the bad line length logic.
x#
x# Note: report_awk does some strange and funky things so that it works
x# with news gatewaying.  Since I have no idea what in the world it
x# was trying to do, I haven't even tried to duplicate it.
x#
x# Report_awk was written by Erik E. Fair <dual!fair>, May 22, 1984.
x#
x
xline: while (<>) {
x	$repline = $_;
x	chop;	# strip record separator
x	@Fld = split(' ');
x
x	if ($#Fld < 0) {
x		next line;
x	}
x
x	if ($Fld[6] eq 'processed') {
x		next line;
x	}
x
x	if ($Fld[8] eq 'beginning') {
x		next line;
x	}
x
x	if ($Fld[7] eq 'finished,') {
x		next line;
x	}
x
x	if ($Fld[5] eq 'sent') {
x		$i = 7;
x		while ($i <= $#Fld) {
x			$host = $Fld[$i];
x			$host =~ s/,$//;
x			$xmited{$host}++;
x			$i++;
x		}				
x		next line;
x	}
x
x	$sys = $Fld[3];
x
x	if ($Fld[4] =~ /^<.*>$/) {
x		$accept{$sys}++;
x		next line;
x	}
x
x	if ($Fld[4] eq 'duplicate') {
x		$reject{$sys}++;		
x		next line;
x	}
x
x	if ($Fld[4] eq 'no' && $Fld[6] eq 'newsgroups') {
x		$junked{$sys}++;
x		next line;
x	}
x
x	if ($Fld[4] eq 'Unknown') {
x		$parse_list = $Fld[5];
x		$parse_list =~ s/'//g;
x		while ($parse_list) {
x			$badgrp{do parse()}++;
x		}
x		$badgrps++;
x		next line;
x	}
x
x	if ($Fld[6] eq 'unsubscribed') {
x		if ($Fld[4] eq 'distribution') {
x			$unsubdists++;
x			$parse_list = $Fld[5];
x			while ($parse_list) {
x				$unsubdist{do parse()}++;
x			}				
x		}
x		if ($Fld[4] eq 'newsgroup(s)') {
x			$unsubgrps++;
x			$parse_list = $Fld[5];
x			while ($parse_list) {
x				$unsubgrp{do parse()}++;
x			}
x		}
x		next line;
x	}
x	
x	if ($Fld[4] eq 'control') {
x		$controls++;
x		$control{$sys}++;
x
x		$cmsg = $_;
x		$cmsg =~ s/^.* from//;
x		$cmsg =~ s/^.*: //;
x		@ctl = split(' ',$cmsg);
x		$ctlcnt{$ctl[0]}++;
x
x		if ($ctl[0] eq 'newgroup') {
x			$newgrp++;
x			$newng{$ctl[1]}++;
x		}
x		next line;		
x	}
x
x	if ($Fld[4] eq 'Cancelling') {
x		$cansucc++;
x		next line;
x	}
x
x	#
x	# articles who actual line count differs from the Line: header count
x	#
x	if ($Fld[5] eq 'expected') {
x		$expect = $Fld[6];
x		$got = $Fld[9];
x		$diff = $got - $expect;
x		$lcount++;
x		$alc_host{$sys} = 1;
x		if ($diff < 0) {
x			$diff = 0 - $diff;
x			$a_nshort{$sys}++;
x			$a_short{$sys} += $diff;
x			if ($a_smax{$sys} < $diff) {
x				$a_smax{$sys} = $diff;
x			}
x		} else {
x			$a_nlong{$sys}++;
x			$a_long{$sys} += $diff;
x			if ($a_lmax{$sys} < $diff) {
x				$a_lmax{$sys} = $diff;
x			}
x		}
x		next line;
x	}
x
x	if ($Fld[7] eq 'zero-length') {
x		$lcount++;
x		$a_zero{$sys}++;
x		$reject{$sys}++;
x		next line;
x	}
x
x	#
x	# Winnow out some junk
x	#
x
x	if ($Fld[4] eq 'unbatching' && $Fld[7] eq 'mode') {
x		next line;
x	}
x
x	#
x	# Print anything we didn't recognize, it's probably an error message.
x	#
x
x	print $repline;
x}
x
x#
x#	Summarize and print the report
x#
x
x$rtot = 0;
xforeach $i (keys(reject)) {
x    if ($reject{$i} > 0) {
x	$list{$i} = 1;
x	$rtot += $reject{$i};
x    }
x}
x
x$atot = 0;
xforeach $i (keys(accept)) {
x    $list{$i} = 1;
x    $atot += $accept{$i};
x}
x
x$ctot = 0;
xforeach $i (keys(control)) {
x    $list{$i} = 1;
x    $ctot += $control{$i};
x}
x
x$jtot = 0;
xforeach $i (keys(junked)) {
x    $list{$i} = 1;
x    $jtot += $junked{$i};
x}
x
x$xtot = 0;
xforeach $i (keys(xmited)) {
x    $list{$i} = 1;
x    $xtot += $xmited{$i};
x}
x#
x# ctot is part of rtot, so we don't add it in to the grand total.
x#
x$totarticles = $atot + $rtot;
xif ($totarticles == 0) {
x    $totarticles = 1;
x
x}
x
xprintf
x  ("\nSystem\t\tAccept\tReject\tJunked\tXmit to\tControl\t% total\t% rejct\n");
x
xforeach $sys (keys(list)) {
x    #
x    #	control & junked are counted under accept.
x    #
x    $sitetot = $accept{$sys} + $reject{$sys};
x    if ($sitetot == 0) {
x	$sitetot = 1;
x    }
x    $articles{$sys} = $sitetot;
x    #
x    # What an 'orrible printf spec
x    #
x    printf("%-14s\t%6d\t%6d\t%6d\t%7d\t%7d\t%6d%%\t%6d%%\n", $sys, 
x	$accept{$sys}, $reject{$sys}, $junked{$sys}, $xmited{$sys}, 
x	$control{$sys}, ($sitetot * 100) / $totarticles, 
x	($reject{$sys} * 100) / $sitetot);
x}
xprintf("\nTOTALS        \t%6d\t%6d\t%6d\t%7d\t%7d\t%6d%%\t%6d%%\n", 
x	$atot, $rtot, $jtot, $xtot, $ctot, 100, ($rtot * 100) / $totarticles);
xprintf("\nTotal Articles processed %d\n", $totarticles);
x
x#
x# Linecount report
x#
xif ($lcount) {
x	printf("\nReceived Article Length Problems\n");
x	printf(
x "System          Zero Short  Smax  Savg  Long  Lmax  Lavg Total % Tot\n");
x	foreach $i (keys(alc_host)) {
x		$nlong = $a_nlong{$i};
x		$nshort = $a_nshort{$i};
x		if ($nlong == 0) {
x		    $nlong = 1;
x		}
x		if ($nshort == 0) {
x		    $nshort = 1;
x		}
x		$lavg = $a_long{$i} / $nlong;
x		$savg = $a_short{$i} / $nshort;
x		$sitebad = ($a_zero{$i} + $a_nshort{$i} + $a_nlong{$i});
x		$sitetot = $articles{$i};
x		if ($sitetot == 0) {
x			$sitetot = 1;
x		}
x		printf("%-14s %5d %5d %5d %5d %5d %5d %5d %5d %4d%%\n", $i,
x			$a_zero{$i}, $a_nshort{$i}, $a_smax{$i}, $savg, 
x			$a_nlong{$i}, $a_lmax{$i}, $lavg, $sitebad, 
x			($sitebad * 100) / $sitetot);
x	}
x}
x
x# Control messages
xif ($controls) {
x	printf("\nControl messages received\n");
x	foreach $ctl (sort(keys(ctlcnt))) {
x		if ($ctl eq 'cancel') {
x			printf("%-20s %3d",$ctl,$ctlcnt{$ctl});
x			if ($cansucc) {
x				printf(", %d succeeded", $cansucc);
x			}
x			printf("\n");
x		} else {
x			printf("%-20s %3d\n",$ctl,$ctlcnt{$ctl});
x		}
x	}
x}
x
x# Unsubscribed distributions
xif ($unsubdists) {
x	printf("\nUnsubscribed distributions received\n");
x	foreach $dist (sort(keys(unsubdist))) {
x		printf("%-30s %3d\n",$dist,$unsubdist{$dist});
x	}
x}
x
x# Unsubscribed newsgroups
xif ($unsubgrps) {
x	printf("\nUnsubscribed newsgroups received\n");
x	foreach $group (sort(keys(unsubgrp))) {
x		printf("%-30s %3d\n",$group,$unsubgrp{$group});
x	}
x}
x
x# Bad newsgroups
xif ($badgrps) {
x	printf("\nBad newsgroups received\n");
x	foreach $group (sort(keys(badgrp))) {
x		printf("%-30s %3d",$group,$badgrp{$group});
x		if ($newng{$group}) {
x			printf(" (created later)\n");
x		} else {
x			printf("\n");
x		}
x	}
x}
x
x# New Newsgroups
xif ($newgrp) {
x	printf("\nNewsgroups created\n");
x
x	foreach $group (sort(keys(newng))) {
x		printf("%s\n", $group);
x	}
x}
x
x
x#
x# Here are some general subroutines!
x#
xsub parse {
x	local($a);
x	$a = $parse_list;
x	if ($a =~ s/,.*$//) {
x		$parse_list =~ s/^[^,]*,//;
x	} else {
x		$parse_list = '';
x	}
x	return($a);
x}
SHAR_EOF
if test 6862 -ne "`wc -c < 'report_perl'`"
then
	echo shar: "error transmitting 'report_perl'" '(should have been 6862 characters)'
fi
chmod +x 'report_perl'
fi
exit 0
#	End of shell archive

