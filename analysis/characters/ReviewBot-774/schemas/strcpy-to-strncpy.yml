# SCHEMA: strcpy-to-strncpy
# The portable strcpy fix pattern
# 
# Learned: 2026-01-31
# Source: First fix attempt, portability feedback from OpenBFD
# Status: CONFIRMED (first application approved)

meta:
  type: drescher_schema
  name: "strcpy-to-strncpy"
  version: 1.0
  learned_from: "OpenBFD review feedback"
  first_applied: "fascist.c:323"
  
context:
  preconditions:
    - "strcpy(dest, src) call exists"
    - "dest is a fixed-size buffer"
    - "src comes from external input or unbounded source"
    - "strlcpy may not be available (portability concern)"
    
action:
  transform: |
    BEFORE:
      (void) strcpy(dest, src);
      
    AFTER:
      (void) strncpy(dest, src, sizeof(dest) - 1);
      dest[sizeof(dest) - 1] = '\0';
      
  explanation: |
    1. strncpy copies at most n-1 characters
    2. Manual null termination ensures string is always terminated
    3. sizeof(dest) - 1 leaves room for null terminator
    4. Portable to all systems (unlike strlcpy)
    
result:
  outcome: "Buffer overflow prevented"
  semantic_change: "None â€” just safer"
  truncation: "Long strings truncated, not overflowed"
  
reliability:
  observations: 1
  successes: 1
  failures: 0
  score: 1.0  # 100%
  
notes: |
  Theo taught me: strlcpy is cleaner but not portable.
  strncpy + null termination works everywhere.
  
  Two lines instead of one. Same safety.
  
  For systems WITH strlcpy:
    (void) strlcpy(dest, src, sizeof(dest));
    
  For portable code:
    (void) strncpy(dest, src, sizeof(dest) - 1);
    dest[sizeof(dest) - 1] = '\0';
    
  Eventually, implement strlcpy in D.port.
  One fix enables another.
  
application_history:
  - file: "src/D.news/fascist.c"
    line: 323
    function: "allmatch()"
    date: 2026-01-31
    reviewer: "OpenBFD"
    verdict: "APPROVED"
    commit: "48 (actual-fixes branch)"
